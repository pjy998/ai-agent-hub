#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListRootsRequestSchema,
  Tool,
} from '@modelcontextprotocol/sdk/types.js';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';
const { logger } = require('./utils/logger.js');

// ÂØºÂÖ•Êñ∞ÁöÑToolsÊ°ÜÊû∂
import { createToolManager, validateWorkspaceRoot, executeToolSafely } from './src/tools/index.js';
import { ToolManager } from './src/tools/manager.js';

interface PresetConfig {
    name: string;
    description: string;
    agents: string[];
    steps: PresetStep[];
}

interface PresetStep {
    name: string;
    agent: string;
    prompt: string;
    output?: string;
}

class AIAgentMCPServer {
    private server: Server;
    private presets: Map<string, PresetConfig> = new Map();
    private toolManager: ToolManager;
    private workspaceRoot: string;

    constructor() {
        // Á°ÆÂÆöÂ∑•‰ΩúÂå∫Ê†πÁõÆÂΩï
        this.workspaceRoot = process.cwd();
        
        // È™åËØÅÂπ∂ÂàùÂßãÂåñÂ∑•‰ΩúÂå∫
        if (!validateWorkspaceRoot(this.workspaceRoot)) {
            console.error(`Invalid workspace root: ${this.workspaceRoot}`);
            process.exit(1);
        }

        // ÂàùÂßãÂåñÂ∑•ÂÖ∑ÁÆ°ÁêÜÂô®
        this.toolManager = createToolManager(this.workspaceRoot);

        this.server = new Server(
            {
                name: 'ai-agent-hub',
                version: '0.0.5', // ÂçáÁ∫ßÁâàÊú¨
            },
            {
                capabilities: {
                    tools: {},
                    roots: {
                        listChanged: true
                    },
                },
            }
        );

        this.loadPresets();
        this.setupToolHandlers();
        this.setupErrorHandling();
    }

    private loadPresets() {
        // Êô∫ËÉΩÊü•ÊâæÈ¢ÑËÆæÁõÆÂΩïÔºö‰ºòÂÖà‰ΩøÁî®Â∑•‰ΩúÂå∫Ë∑ØÂæÑÔºåÂõûÈÄÄÂà∞Áõ∏ÂØπË∑ØÂæÑ
        let presetsDir = path.join(process.cwd(), 'agents', 'presets');
        
        // Â¶ÇÊûúÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩï‰∏ãÊ≤°ÊúâÈ¢ÑËÆæÔºåÂ∞ùËØïÊü•ÊâæÈ°πÁõÆÊ†πÁõÆÂΩï
        if (!fs.existsSync(presetsDir)) {
            // ‰ªéÂΩìÂâçËÑöÊú¨‰ΩçÁΩÆÂêë‰∏äÊü•ÊâæÈ°πÁõÆÊ†πÁõÆÂΩï
            const currentDir = path.dirname(__filename);
            const projectRoot = path.resolve(currentDir, '../../..');
            const rootPresetsDir = path.join(projectRoot, 'agents', 'presets');
            
            if (fs.existsSync(rootPresetsDir)) {
                presetsDir = rootPresetsDir;
                logger.mcpDebug(`Found presets in project root: ${presetsDir}`);
            } else {
                console.error(`Presets directory not found in either location:`);
                console.error(`  - Working directory: ${path.join(process.cwd(), 'agents', 'presets')}`);
                console.error(`  - Project root: ${rootPresetsDir}`);
                console.error(`Current working directory: ${process.cwd()}`);
                return;
            }
        } else {
            logger.mcpDebug(`Found presets in working directory: ${presetsDir}`);
        }

        const presetFiles = fs.readdirSync(presetsDir).filter(file => file.endsWith('.yaml'));
        
        for (const file of presetFiles) {
            try {
                const content = fs.readFileSync(path.join(presetsDir, file), 'utf8');
                const preset = yaml.parse(content) as PresetConfig;
                this.presets.set(preset.name, preset);
                console.error(`Loaded preset: ${preset.name}`);
            } catch (error) {
                console.error(`Failed to load preset ${file}:`, error);
            }
        }
    }

    private setupToolHandlers() {
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            // ÁªÑÂêàÈ¢ÑËÆæÂ∑•ÂÖ∑ÂíåÂü∫Á°ÄÂ∑•ÂÖ∑
            const presetTools: Tool[] = [
                {
                    name: 'execute_workflow',
                    description: 'Execute an AI workflow preset',
                    inputSchema: {
                        type: 'object',
                        properties: {
                            presetName: {
                                type: 'string',
                                description: 'Name of the workflow preset to execute',
                                enum: Array.from(this.presets.keys())
                            },
                            context: {
                                type: 'object',
                                properties: {
                                    file: { type: 'string', description: 'File path' },
                                    language: { type: 'string', description: 'Programming language' },
                                    selection: { type: 'string', description: 'Selected code' },
                                    gitDiff: { type: 'string', description: 'Git diff' },
                                    prompt: { type: 'string', description: 'User prompt/query' }
                                }
                            }
                        },
                        required: ['presetName']
                    }
                },
                {
                    name: 'list_presets',
                    description: 'List all available workflow presets',
                    inputSchema: {
                        type: 'object',
                        properties: {}
                    }
                },
                {
                    name: 'get_project_info', 
                    description: 'Get project information and structure',
                    inputSchema: {
                        type: 'object',
                        properties: {}
                    }
                }
            ];

            // Ëé∑ÂèñÂ∑•ÂÖ∑Ê°ÜÊû∂Êèê‰æõÁöÑÂ∑•ÂÖ∑
            const frameworkTools = this.toolManager.getToolConfigs();
            
            // ËΩ¨Êç¢‰∏∫MCP ToolÊ†ºÂºè
            const mcpFrameworkTools: Tool[] = frameworkTools.map(tool => ({
                name: tool.name,
                description: tool.description,
                inputSchema: {
                    type: "object" as const,
                    properties: tool.inputSchema.properties,
                    required: tool.inputSchema.required || []
                }
            }));

            // ÁªÑÂêàÊâÄÊúâÂ∑•ÂÖ∑
            const allTools = [...presetTools, ...mcpFrameworkTools];
            
            logger.mcpDebug(`üîß Providing ${allTools.length} tools: ${allTools.map(t => t.name).join(', ')}`);
            
            return { tools: allTools };
        });

        // Ê∑ªÂä†RootsÂçèËÆÆÊîØÊåÅ
        this.server.setRequestHandler(ListRootsRequestSchema, async () => {
            const workspaceRoot = process.cwd();
            const presetsPath = path.join(workspaceRoot, 'agents', 'presets');
            
            const roots = [
                {
                    uri: `file://${workspaceRoot}`,
                    name: path.basename(workspaceRoot) || 'Project Root'
                }
            ];
            
            // Â¶ÇÊûúÈ¢ÑËÆæÁõÆÂΩïÂ≠òÂú®Ôºå‰πüÊ∑ªÂä†‰∏∫Ê†πÁõÆÂΩï
            if (fs.existsSync(presetsPath)) {
                roots.push({
                    uri: `file://${presetsPath}`,
                    name: 'AI Agent Presets'
                });
            }
            
            logger.mcpDebug(`üìÅ Providing roots: ${roots.map(r => r.name).join(', ')}`);
            return { roots };
        });

        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;

            try {
                switch (name) {
                    // È¢ÑËÆæÁõ∏ÂÖ≥Â∑•ÂÖ∑
                    case 'execute_workflow':
                        if (!args) throw new Error('Missing arguments');
                        return await this.runWorkflow(args.presetName as string, args.context || {});
                    
                    case 'list_presets':
                        return {
                            content: [
                                {
                                    type: 'text',
                                    text: JSON.stringify(
                                        Array.from(this.presets.values()).map(p => ({
                                            name: p.name,
                                            description: p.description,
                                            agents: p.agents
                                        })),
                                        null,
                                        2
                                    )
                                }
                            ]
                        };

                    case 'get_project_info':
                        return await this.getProjectInfo();

                    default:
                        // Â∞ùËØï‰ΩøÁî®Â∑•ÂÖ∑Ê°ÜÊû∂ÊâßË°åÂ∑•ÂÖ∑
                        if (this.toolManager.hasTool(name)) {
                            const result = await executeToolSafely(
                                this.toolManager,
                                name,
                                args || {},
                                {
                                    workspaceRoot: this.workspaceRoot,
                                    timestamp: Date.now()
                                }
                            );

                            return {
                                content: [
                                    {
                                        type: 'text',
                                        text: result.success 
                                            ? (result.result || 'Operation completed successfully')
                                            : `Error: ${result.error}`
                                    }
                                ]
                            };
                        }

                        throw new Error(`Unknown tool: ${name}`);
                }
            } catch (error) {
                logger.mcpDebug(`üí• Tool execution error: ${name}`, error);
                
                return {
                    content: [
                        {
                            type: 'text',
                            text: `Error executing ${name}: ${error instanceof Error ? error.message : 'Unknown error'}`
                        }
                    ]
                };
            }
        });
    }

    private async runWorkflow(presetName: string, context: any) {
        const preset = this.presets.get(presetName);
        if (!preset) {
            throw new Error(`Preset not found: ${presetName}`);
        }

        const results: any = {};
        const replay: any[] = [];

        for (const step of preset.steps) {
            const prompt = this.buildPrompt(step.prompt, context);
            const response = await this.executeStep(step, prompt, context);
            
            replay.push({
                step: step.name,
                agent: step.agent,
                prompt,
                response,
                timestamp: new Date().toISOString()
            });

            if (step.output) {
                results[step.output] = response;
            }
        }

        return {
            content: [
                {
                    type: 'text',
                    text: JSON.stringify({ ...results, replay }, null, 2)
                }
            ]
        };
    }

    private async getProjectInfo() {
        const packageJsonPath = path.join(this.workspaceRoot, 'package.json');
        let projectInfo: any = {
            workspaceRoot: this.workspaceRoot,
            timestamp: new Date().toISOString()
        };

        try {
            if (fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                projectInfo.package = {
                    name: packageJson.name,
                    version: packageJson.version,
                    description: packageJson.description,
                    main: packageJson.main,
                    scripts: packageJson.scripts,
                    dependencies: Object.keys(packageJson.dependencies || {}),
                    devDependencies: Object.keys(packageJson.devDependencies || {})
                };
            }

            // Ëé∑ÂèñÂ∑•ÂÖ∑ÁªüËÆ°‰ø°ÊÅØ
            const toolStats = this.toolManager.getExecutionSummary();
            projectInfo.tools = {
                available: this.toolManager.listToolNames(),
                stats: toolStats
            };

        } catch (error) {
            projectInfo.error = error instanceof Error ? error.message : 'Unknown error';
        }

        return {
            content: [
                {
                    type: 'text',
                    text: JSON.stringify(projectInfo, null, 2)
                }
            ]
        };
    }

    private buildPrompt(template: string, context: any): string {
        let prompt = template;
        Object.keys(context).forEach(key => {
            const placeholder = `{{${key}}}`;
            if (prompt.includes(placeholder)) {
                prompt = prompt.replace(new RegExp(placeholder, 'g'), context[key] || '');
            }
        });
        return prompt;
    }

    private async executeStep(step: PresetStep, prompt: string, context: any): Promise<string> {
        // Áé∞Âú®Êàë‰ª¨ÊúâÁúüÂÆûÁöÑÂ∑•ÂÖ∑Ôºå‰ΩÜAIÊ®°ÂûãÈõÜÊàêËøòÂú®ÂºÄÂèë‰∏≠
        // ÊöÇÊó∂‰ΩøÁî®Â¢ûÂº∫ÁöÑmockÂìçÂ∫îÔºåÂ±ïÁ§∫Â∑•ÂÖ∑‰ΩøÁî®ÊΩúÂäõ
        
        logger.mcpDebug(`ü§ñ Executing step: ${step.name} with agent: ${step.agent}`);
        
        try {
            switch (step.agent) {
                case 'coder':
                    // Ê®°Êãü‰ΩøÁî®Êñá‰ª∂ÂÜôÂÖ•Â∑•ÂÖ∑
                    const fileName = context.file ? path.basename(context.file) : 'generated.js';
                    const codeContent = this.generateMockCode(prompt, context);
                    
                    return `${codeContent}\n\n// üí° ÊèêÁ§∫: ‰∏ÄÊó¶AIÊ®°ÂûãÈõÜÊàêÂÆåÊàêÔºåËøôÂ∞ÜÊòØÁúüÊ≠£Áî±AIÁîüÊàêÁöÑ‰ª£Á†Å\n// üîß ÂèØ‰ΩøÁî®Â∑•ÂÖ∑: ${this.toolManager.listToolNames().join(', ')}`;
                
                case 'tester':
                    const testContent = this.generateMockTests(prompt, context);
                    return `${testContent}\n\n// üí° ÊèêÁ§∫: ‰∏ÄÊó¶AIÊ®°ÂûãÈõÜÊàêÂÆåÊàêÔºåËøôÂ∞ÜÊòØÁúüÊ≠£Áî±AIÁîüÊàêÁöÑÊµãËØï\n// üîß ÂèØÁî®Â∑•ÂÖ∑: runShell (ÊâßË°åÊµãËØï), writeFile (‰øùÂ≠òÊµãËØïÊñá‰ª∂)`;
                
                case 'requirements':
                    const analysisContent = this.generateMockAnalysis(prompt, context);
                    return `${analysisContent}\n\n// üí° ÊèêÁ§∫: ‰∏ÄÊó¶AIÊ®°ÂûãÈõÜÊàêÂÆåÊàêÔºåËøôÂ∞ÜÊòØÁúüÊ≠£ÁöÑÈúÄÊ±ÇÂàÜÊûê\n// üîß ÂèØÁî®Â∑•ÂÖ∑: searchFiles (ÂàÜÊûêÁé∞Êúâ‰ª£Á†Å), readFile (ÁêÜËß£È°πÁõÆÁªìÊûÑ)`;
                
                default:
                    return `ü§ñ Agent "${step.agent}" ÂáÜÂ§áÂ∞±Áª™ÔºåÁ≠âÂæÖAIÊ®°ÂûãÈõÜÊàê\nüìù Prompt: ${prompt.substring(0, 100)}...\nüîß ÂèØÁî®Â∑•ÂÖ∑: ${this.toolManager.listToolNames().join(', ')}\n‚ö° Â∑•ÂÖ∑ÁªüËÆ°: ${JSON.stringify(this.toolManager.getExecutionSummary())}`;
            }
        } catch (error) {
            logger.mcpDebug(`‚ùå Step execution error: ${step.name}`, error);
            return `Error in ${step.agent}: ${error instanceof Error ? error.message : 'Unknown error'}`;
        }
    }

    private generateMockCode(prompt: string, context: any): string {
        const language = context.language || 'javascript';
        const fileName = context.file ? path.basename(context.file) : 'unknown';
        
        return `// AI Generated Code for ${fileName} (${language})
// Based on prompt: ${prompt.substring(0, 50)}...

${language === 'typescript' ? `
interface GeneratedInterface {
    id: string;
    data: any;
    process(): Promise<boolean>;
}

class AIGeneratedClass implements GeneratedInterface {
    constructor(public id: string, public data: any) {}
    
    async process(): Promise<boolean> {
        console.log('Processing with AI Agent Hub');
        return true;
    }
}
` : `
function aiGeneratedFunction(data) {
    console.log('Generated by AI Agent Hub v0.0.5');
    console.log('Context:', data);
    return { success: true, processed: true };
}

module.exports = { aiGeneratedFunction };
`}`;
    }

    private generateMockTests(prompt: string, context: any): string {
        return `// AI Generated Tests
// Based on: ${prompt.substring(0, 50)}...

describe('AI Generated Test Suite', () => {
    test('should handle basic functionality', () => {
        expect(true).toBe(true);
    });
    
    test('should process data correctly', async () => {
        const result = await processData('test');
        expect(result.success).toBe(true);
    });
    
    test('should handle error cases', () => {
        expect(() => {
            throw new Error('test error');
        }).toThrow('test error');
    });
});`;
    }

    private generateMockAnalysis(prompt: string, context: any): string {
        return `# AIÈúÄÊ±ÇÂàÜÊûêÊä•Âëä

## Áî®Êà∑ÈúÄÊ±Ç
${prompt}

## ‰∏ä‰∏ãÊñáÂàÜÊûê
- ÂΩìÂâçÊñá‰ª∂: ${context.file || 'Êú™ÊåáÂÆö'}
- ÁºñÁ®ãËØ≠Ë®Ä: ${context.language || 'Êú™ÊåáÂÆö'}
- ÈÄâ‰∏≠‰ª£Á†Å: ${context.selection ? 'ÊòØ' : 'Âê¶'}

## Âª∫ËÆÆÁöÑÂÆûÁé∞Ê≠•È™§
1. ÂàÜÊûêÁé∞Êúâ‰ª£Á†ÅÁªìÊûÑ
2. ËÆæËÆ°Êé•Âè£ÂíåÊï∞ÊçÆÊ®°Âûã
3. ÂÆûÁé∞Ê†∏ÂøÉÂäüËÉΩ
4. Ê∑ªÂä†ÈîôËØØÂ§ÑÁêÜ
5. ÁºñÂÜôÂçïÂÖÉÊµãËØï
6. ÈõÜÊàêÊµãËØï

## ÂèØÁî®Â∑•ÂÖ∑Âª∫ËÆÆ
- writeFile: ÂàõÂª∫Êñ∞Êñá‰ª∂
- readFile: ÂàÜÊûêÁé∞Êúâ‰ª£Á†Å
- searchFiles: Êü•ÊâæÁõ∏ÂÖ≥Êñá‰ª∂
- git: ÁâàÊú¨ÊéßÂà∂Êìç‰Ωú
- runShell: ÊâßË°åÊûÑÂª∫ÂíåÊµãËØï

## È¢Ñ‰º∞Â§çÊùÇÂ∫¶
‰∏≠Á≠â - È¢ÑËÆ°ÈúÄË¶Å‰ΩøÁî®Â§ö‰∏™Â∑•ÂÖ∑Âçè‰ΩúÂÆåÊàê`;
    }

    private setupErrorHandling() {
        this.server.onerror = (error) => {
            console.error('[MCP Error]', error);
        };

        process.on('SIGINT', async () => {
            await this.server.close();
            process.exit(0);
        });
    }

    async run() {
        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        
        // ÂêØÂä®Êó∂ÊòæÁ§∫ÁâàÊú¨‰ø°ÊÅØ
        logger.mcpStartup(`AI Agent Hub MCP Server v0.0.4 started successfully`);
        logger.mcpStartup(`Working directory: ${process.cwd()}`);
    }
}

const server = new AIAgentMCPServer();
server.run().catch(console.error);